执行上下文:
执行上下文可以抽象的理解为object，上面有一系列的属性，包含了你能够访问到的属性和方法.
每个执行上下文都有以下属性：变量对象，作用域链，this

变量对象(VO):
与执行上下文相关的数据作用域，用来存储在上文中定义变量和函数声明(函数表达式不包含在内)
进入上下文时初始化创建，值的更新在代码执行阶段
1.全局上下文的变量对象是可以访问的，即为全局对象。
2.函数上下文的变量对象不能直接访问，函数被激活后，VO变成AO。
AO通过arguments属性初始化
3.执行上下文的代码分为两个阶段进入上下文和执行代码

进入执行上下文:
函数的形参：由名称和对应值组成，没有传递值，则为undefined
函数声明：如果存在同名属性，则替换这个属性
变量声明：初始化值都为undefined，如果变量名称跟已经声明的形参或者函数相同，则变量声明不会干扰已经存在的属性
（函数声明是在进入执行上下文阶段填入的，如果此时有同名变量，则后者不会干扰它）


代码执行：
根据实际情况（代码执行情况）修改变量值
(写命名函数表达式的问题：代码执行阶段查找在进入执行上下文阶段是否有对应的函数，未发现，则返回not defined)

关于变量：变量只能通过var，let才能声明(const声明一个常量)
1.所谓创建全局变量只是为全局对象创建一个新属性，它不是一个变量(不是因为值不能改变，而是不符合ecmascript对变量的规范，它之所以能成为全局对象的属性，是以为全局上下文的变量对象就是全局对象)
2.这个所谓的全局变量只在代码执行阶段出现

this:
1.全局代码中的this：始终指向全局对象本身
2.函数代码中的this:this是在进入上下文确定的，在代码执行阶段this是不会该Bain的。所以this不是一个变量,this值的情况由函数调用者决定
3.判断this:
引用类型：处理一个标识符时，或者一个属性访问器。
标识符：变量名，函数名，函数参数名
引用类型的base值：调用函数的父级上下文
1)如果括号左边时引用类型，则返回引用类型的base值
2)如果不为引用类型，则返回null，但实际上会隐式转换成全局对象
3)为了从引用类型获得对象真正的值，需要调用GetValue方法，所以在遇到运算符号时，由于需要引用类型的真正的值，所以调用了GetValue方法，此时就不为引用类型了.

作用域链：
1.创建函数时，自动创建[[Scope]]内部属性，属性中保存父级上下文的VO/AO
2.函数激活：
Scope:[AO].concat([[Scope]])
3.二维作用域链查找
